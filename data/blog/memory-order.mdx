---
title: 'Memory Order: A Top-Down Approach'
date: '2023-11-04'
lastmod: '2023-11-04'
tags: ['C++', 'programming']
draft: true
summary: My take on C++ memory models
images: []
authors: ['default']
---

I tried to write about memory order once. But I could not made it until the end. I think the cause is that the blog post has been delayed for months. With a protracted writing period, the motivation diminished. This time I will come out with a whole introduction, from how C++ standard says down to how to implement them in CPUs.

## C++ Memory Order

Let us begin with a multi-threaded counter.

```cpp
#include <cassert>
#include <chrono>
#include <iostream>

using namespace std::chrono_literals;

bool done = false;

void producer(int& product, bool& ready) {
    int some_product = 0;
    while (!done) {
        if (!ready) {
            product = some_product;
            ready = true;
        }
        std::this_thread::sleep_for(100ms);
        std::cout << "Produced " << some_product << std::endl;
        some_product++;
    }
}

void consumer(int& product, bool& ready) {
    int consumed_product = 0;
    while (!done) {
        if (ready) {
            consumed_product = product;
            ready = false;
            std::cout << "Consumed " << consumed_product << std::endl;
        }
        std::this_thread::sleep_for(100ms);
    }
}

int main() {
    int product = 0;
    bool ready = false;
    auto producer_thread = std::thread([&]() { producer(product, ready); });
    auto consumer_thread = std::thread([&]() { consumer(product, ready); });

    std::this_thread::sleep_for(3s);
    done = true;

    producer_thread.join();
    consumer_thread.join();

    return 0;
}
```

This program